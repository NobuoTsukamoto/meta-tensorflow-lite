diff --git a/api/driver_options_generated.h b/api/driver_options_generated.h
new file mode 100644
index 0000000..f5d9154
--- /dev/null
+++ b/api/driver_options_generated.h
@@ -0,0 +1,684 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_DRIVEROPTIONS_PLATFORMS_DARWINN_API_H_
+#define FLATBUFFERS_GENERATED_DRIVEROPTIONS_PLATFORMS_DARWINN_API_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+namespace platforms {
+namespace darwinn {
+namespace api {
+
+struct DriverUsbOptions;
+struct DriverUsbOptionsBuilder;
+struct DriverUsbOptionsT;
+
+struct DriverOptions;
+struct DriverOptionsBuilder;
+struct DriverOptionsT;
+
+enum PerformanceExpectation : int32_t {
+  PerformanceExpectation_Low = 0,
+  PerformanceExpectation_Medium = 1,
+  PerformanceExpectation_High = 2,
+  PerformanceExpectation_Max = 3,
+  PerformanceExpectation_MIN = PerformanceExpectation_Low,
+  PerformanceExpectation_MAX = PerformanceExpectation_Max
+};
+
+inline const PerformanceExpectation (&EnumValuesPerformanceExpectation())[4] {
+  static const PerformanceExpectation values[] = {
+    PerformanceExpectation_Low,
+    PerformanceExpectation_Medium,
+    PerformanceExpectation_High,
+    PerformanceExpectation_Max
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPerformanceExpectation() {
+  static const char * const names[5] = {
+    "Low",
+    "Medium",
+    "High",
+    "Max",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePerformanceExpectation(PerformanceExpectation e) {
+  if (flatbuffers::IsOutRange(e, PerformanceExpectation_Low, PerformanceExpectation_Max)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPerformanceExpectation()[index];
+}
+
+struct DriverUsbOptionsT : public flatbuffers::NativeTable {
+  typedef DriverUsbOptions TableType;
+  std::string dfu_firmware{};
+  bool always_dfu = true;
+  bool has_fail_if_slower_than_superspeed = false;
+  bool fail_if_slower_than_superspeed = false;
+  bool has_force_largest_bulk_in_chunk_size = false;
+  bool force_largest_bulk_in_chunk_size = false;
+  bool has_enable_overlapping_bulk_in_and_out = false;
+  bool enable_overlapping_bulk_in_and_out = true;
+  bool has_enable_queued_bulk_in_requests = false;
+  bool enable_queued_bulk_in_requests = true;
+  bool has_bulk_in_queue_capacity = false;
+  int32_t bulk_in_queue_capacity = 32;
+};
+
+struct DriverUsbOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DriverUsbOptionsT NativeTableType;
+  typedef DriverUsbOptionsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DFU_FIRMWARE = 4,
+    VT_ALWAYS_DFU = 6,
+    VT_HAS_FAIL_IF_SLOWER_THAN_SUPERSPEED = 8,
+    VT_FAIL_IF_SLOWER_THAN_SUPERSPEED = 10,
+    VT_HAS_FORCE_LARGEST_BULK_IN_CHUNK_SIZE = 12,
+    VT_FORCE_LARGEST_BULK_IN_CHUNK_SIZE = 14,
+    VT_HAS_ENABLE_OVERLAPPING_BULK_IN_AND_OUT = 16,
+    VT_ENABLE_OVERLAPPING_BULK_IN_AND_OUT = 18,
+    VT_HAS_ENABLE_QUEUED_BULK_IN_REQUESTS = 20,
+    VT_ENABLE_QUEUED_BULK_IN_REQUESTS = 22,
+    VT_HAS_BULK_IN_QUEUE_CAPACITY = 24,
+    VT_BULK_IN_QUEUE_CAPACITY = 26
+  };
+  const flatbuffers::String *dfu_firmware() const {
+    return GetPointer<const flatbuffers::String *>(VT_DFU_FIRMWARE);
+  }
+  flatbuffers::String *mutable_dfu_firmware() {
+    return GetPointer<flatbuffers::String *>(VT_DFU_FIRMWARE);
+  }
+  bool always_dfu() const {
+    return GetField<uint8_t>(VT_ALWAYS_DFU, 1) != 0;
+  }
+  bool mutate_always_dfu(bool _always_dfu = 1) {
+    return SetField<uint8_t>(VT_ALWAYS_DFU, static_cast<uint8_t>(_always_dfu), 1);
+  }
+  bool has_fail_if_slower_than_superspeed() const {
+    return GetField<uint8_t>(VT_HAS_FAIL_IF_SLOWER_THAN_SUPERSPEED, 0) != 0;
+  }
+  bool mutate_has_fail_if_slower_than_superspeed(bool _has_fail_if_slower_than_superspeed = 0) {
+    return SetField<uint8_t>(VT_HAS_FAIL_IF_SLOWER_THAN_SUPERSPEED, static_cast<uint8_t>(_has_fail_if_slower_than_superspeed), 0);
+  }
+  bool fail_if_slower_than_superspeed() const {
+    return GetField<uint8_t>(VT_FAIL_IF_SLOWER_THAN_SUPERSPEED, 0) != 0;
+  }
+  bool mutate_fail_if_slower_than_superspeed(bool _fail_if_slower_than_superspeed = 0) {
+    return SetField<uint8_t>(VT_FAIL_IF_SLOWER_THAN_SUPERSPEED, static_cast<uint8_t>(_fail_if_slower_than_superspeed), 0);
+  }
+  bool has_force_largest_bulk_in_chunk_size() const {
+    return GetField<uint8_t>(VT_HAS_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, 0) != 0;
+  }
+  bool mutate_has_force_largest_bulk_in_chunk_size(bool _has_force_largest_bulk_in_chunk_size = 0) {
+    return SetField<uint8_t>(VT_HAS_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, static_cast<uint8_t>(_has_force_largest_bulk_in_chunk_size), 0);
+  }
+  bool force_largest_bulk_in_chunk_size() const {
+    return GetField<uint8_t>(VT_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, 0) != 0;
+  }
+  bool mutate_force_largest_bulk_in_chunk_size(bool _force_largest_bulk_in_chunk_size = 0) {
+    return SetField<uint8_t>(VT_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, static_cast<uint8_t>(_force_largest_bulk_in_chunk_size), 0);
+  }
+  bool has_enable_overlapping_bulk_in_and_out() const {
+    return GetField<uint8_t>(VT_HAS_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, 0) != 0;
+  }
+  bool mutate_has_enable_overlapping_bulk_in_and_out(bool _has_enable_overlapping_bulk_in_and_out = 0) {
+    return SetField<uint8_t>(VT_HAS_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, static_cast<uint8_t>(_has_enable_overlapping_bulk_in_and_out), 0);
+  }
+  bool enable_overlapping_bulk_in_and_out() const {
+    return GetField<uint8_t>(VT_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, 1) != 0;
+  }
+  bool mutate_enable_overlapping_bulk_in_and_out(bool _enable_overlapping_bulk_in_and_out = 1) {
+    return SetField<uint8_t>(VT_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, static_cast<uint8_t>(_enable_overlapping_bulk_in_and_out), 1);
+  }
+  bool has_enable_queued_bulk_in_requests() const {
+    return GetField<uint8_t>(VT_HAS_ENABLE_QUEUED_BULK_IN_REQUESTS, 0) != 0;
+  }
+  bool mutate_has_enable_queued_bulk_in_requests(bool _has_enable_queued_bulk_in_requests = 0) {
+    return SetField<uint8_t>(VT_HAS_ENABLE_QUEUED_BULK_IN_REQUESTS, static_cast<uint8_t>(_has_enable_queued_bulk_in_requests), 0);
+  }
+  bool enable_queued_bulk_in_requests() const {
+    return GetField<uint8_t>(VT_ENABLE_QUEUED_BULK_IN_REQUESTS, 1) != 0;
+  }
+  bool mutate_enable_queued_bulk_in_requests(bool _enable_queued_bulk_in_requests = 1) {
+    return SetField<uint8_t>(VT_ENABLE_QUEUED_BULK_IN_REQUESTS, static_cast<uint8_t>(_enable_queued_bulk_in_requests), 1);
+  }
+  bool has_bulk_in_queue_capacity() const {
+    return GetField<uint8_t>(VT_HAS_BULK_IN_QUEUE_CAPACITY, 0) != 0;
+  }
+  bool mutate_has_bulk_in_queue_capacity(bool _has_bulk_in_queue_capacity = 0) {
+    return SetField<uint8_t>(VT_HAS_BULK_IN_QUEUE_CAPACITY, static_cast<uint8_t>(_has_bulk_in_queue_capacity), 0);
+  }
+  int32_t bulk_in_queue_capacity() const {
+    return GetField<int32_t>(VT_BULK_IN_QUEUE_CAPACITY, 32);
+  }
+  bool mutate_bulk_in_queue_capacity(int32_t _bulk_in_queue_capacity = 32) {
+    return SetField<int32_t>(VT_BULK_IN_QUEUE_CAPACITY, _bulk_in_queue_capacity, 32);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DFU_FIRMWARE) &&
+           verifier.VerifyString(dfu_firmware()) &&
+           VerifyField<uint8_t>(verifier, VT_ALWAYS_DFU, 1) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_FAIL_IF_SLOWER_THAN_SUPERSPEED, 1) &&
+           VerifyField<uint8_t>(verifier, VT_FAIL_IF_SLOWER_THAN_SUPERSPEED, 1) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, 1) &&
+           VerifyField<uint8_t>(verifier, VT_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, 1) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, 1) &&
+           VerifyField<uint8_t>(verifier, VT_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, 1) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_ENABLE_QUEUED_BULK_IN_REQUESTS, 1) &&
+           VerifyField<uint8_t>(verifier, VT_ENABLE_QUEUED_BULK_IN_REQUESTS, 1) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BULK_IN_QUEUE_CAPACITY, 1) &&
+           VerifyField<int32_t>(verifier, VT_BULK_IN_QUEUE_CAPACITY, 4) &&
+           verifier.EndTable();
+  }
+  DriverUsbOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DriverUsbOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DriverUsbOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DriverUsbOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DriverUsbOptionsBuilder {
+  typedef DriverUsbOptions Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_dfu_firmware(flatbuffers::Offset<flatbuffers::String> dfu_firmware) {
+    fbb_.AddOffset(DriverUsbOptions::VT_DFU_FIRMWARE, dfu_firmware);
+  }
+  void add_always_dfu(bool always_dfu) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_ALWAYS_DFU, static_cast<uint8_t>(always_dfu), 1);
+  }
+  void add_has_fail_if_slower_than_superspeed(bool has_fail_if_slower_than_superspeed) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_HAS_FAIL_IF_SLOWER_THAN_SUPERSPEED, static_cast<uint8_t>(has_fail_if_slower_than_superspeed), 0);
+  }
+  void add_fail_if_slower_than_superspeed(bool fail_if_slower_than_superspeed) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_FAIL_IF_SLOWER_THAN_SUPERSPEED, static_cast<uint8_t>(fail_if_slower_than_superspeed), 0);
+  }
+  void add_has_force_largest_bulk_in_chunk_size(bool has_force_largest_bulk_in_chunk_size) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_HAS_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, static_cast<uint8_t>(has_force_largest_bulk_in_chunk_size), 0);
+  }
+  void add_force_largest_bulk_in_chunk_size(bool force_largest_bulk_in_chunk_size) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_FORCE_LARGEST_BULK_IN_CHUNK_SIZE, static_cast<uint8_t>(force_largest_bulk_in_chunk_size), 0);
+  }
+  void add_has_enable_overlapping_bulk_in_and_out(bool has_enable_overlapping_bulk_in_and_out) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_HAS_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, static_cast<uint8_t>(has_enable_overlapping_bulk_in_and_out), 0);
+  }
+  void add_enable_overlapping_bulk_in_and_out(bool enable_overlapping_bulk_in_and_out) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_ENABLE_OVERLAPPING_BULK_IN_AND_OUT, static_cast<uint8_t>(enable_overlapping_bulk_in_and_out), 1);
+  }
+  void add_has_enable_queued_bulk_in_requests(bool has_enable_queued_bulk_in_requests) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_HAS_ENABLE_QUEUED_BULK_IN_REQUESTS, static_cast<uint8_t>(has_enable_queued_bulk_in_requests), 0);
+  }
+  void add_enable_queued_bulk_in_requests(bool enable_queued_bulk_in_requests) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_ENABLE_QUEUED_BULK_IN_REQUESTS, static_cast<uint8_t>(enable_queued_bulk_in_requests), 1);
+  }
+  void add_has_bulk_in_queue_capacity(bool has_bulk_in_queue_capacity) {
+    fbb_.AddElement<uint8_t>(DriverUsbOptions::VT_HAS_BULK_IN_QUEUE_CAPACITY, static_cast<uint8_t>(has_bulk_in_queue_capacity), 0);
+  }
+  void add_bulk_in_queue_capacity(int32_t bulk_in_queue_capacity) {
+    fbb_.AddElement<int32_t>(DriverUsbOptions::VT_BULK_IN_QUEUE_CAPACITY, bulk_in_queue_capacity, 32);
+  }
+  explicit DriverUsbOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DriverUsbOptions> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DriverUsbOptions>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DriverUsbOptions> CreateDriverUsbOptions(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> dfu_firmware = 0,
+    bool always_dfu = true,
+    bool has_fail_if_slower_than_superspeed = false,
+    bool fail_if_slower_than_superspeed = false,
+    bool has_force_largest_bulk_in_chunk_size = false,
+    bool force_largest_bulk_in_chunk_size = false,
+    bool has_enable_overlapping_bulk_in_and_out = false,
+    bool enable_overlapping_bulk_in_and_out = true,
+    bool has_enable_queued_bulk_in_requests = false,
+    bool enable_queued_bulk_in_requests = true,
+    bool has_bulk_in_queue_capacity = false,
+    int32_t bulk_in_queue_capacity = 32) {
+  DriverUsbOptionsBuilder builder_(_fbb);
+  builder_.add_bulk_in_queue_capacity(bulk_in_queue_capacity);
+  builder_.add_dfu_firmware(dfu_firmware);
+  builder_.add_has_bulk_in_queue_capacity(has_bulk_in_queue_capacity);
+  builder_.add_enable_queued_bulk_in_requests(enable_queued_bulk_in_requests);
+  builder_.add_has_enable_queued_bulk_in_requests(has_enable_queued_bulk_in_requests);
+  builder_.add_enable_overlapping_bulk_in_and_out(enable_overlapping_bulk_in_and_out);
+  builder_.add_has_enable_overlapping_bulk_in_and_out(has_enable_overlapping_bulk_in_and_out);
+  builder_.add_force_largest_bulk_in_chunk_size(force_largest_bulk_in_chunk_size);
+  builder_.add_has_force_largest_bulk_in_chunk_size(has_force_largest_bulk_in_chunk_size);
+  builder_.add_fail_if_slower_than_superspeed(fail_if_slower_than_superspeed);
+  builder_.add_has_fail_if_slower_than_superspeed(has_fail_if_slower_than_superspeed);
+  builder_.add_always_dfu(always_dfu);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<DriverUsbOptions> CreateDriverUsbOptionsDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *dfu_firmware = nullptr,
+    bool always_dfu = true,
+    bool has_fail_if_slower_than_superspeed = false,
+    bool fail_if_slower_than_superspeed = false,
+    bool has_force_largest_bulk_in_chunk_size = false,
+    bool force_largest_bulk_in_chunk_size = false,
+    bool has_enable_overlapping_bulk_in_and_out = false,
+    bool enable_overlapping_bulk_in_and_out = true,
+    bool has_enable_queued_bulk_in_requests = false,
+    bool enable_queued_bulk_in_requests = true,
+    bool has_bulk_in_queue_capacity = false,
+    int32_t bulk_in_queue_capacity = 32) {
+  auto dfu_firmware__ = dfu_firmware ? _fbb.CreateString(dfu_firmware) : 0;
+  return platforms::darwinn::api::CreateDriverUsbOptions(
+      _fbb,
+      dfu_firmware__,
+      always_dfu,
+      has_fail_if_slower_than_superspeed,
+      fail_if_slower_than_superspeed,
+      has_force_largest_bulk_in_chunk_size,
+      force_largest_bulk_in_chunk_size,
+      has_enable_overlapping_bulk_in_and_out,
+      enable_overlapping_bulk_in_and_out,
+      has_enable_queued_bulk_in_requests,
+      enable_queued_bulk_in_requests,
+      has_bulk_in_queue_capacity,
+      bulk_in_queue_capacity);
+}
+
+flatbuffers::Offset<DriverUsbOptions> CreateDriverUsbOptions(flatbuffers::FlatBufferBuilder &_fbb, const DriverUsbOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DriverOptionsT : public flatbuffers::NativeTable {
+  typedef DriverOptions TableType;
+  int32_t version = 1;
+  std::unique_ptr<platforms::darwinn::api::DriverUsbOptionsT> usb{};
+  int32_t verbosity = 0;
+  platforms::darwinn::api::PerformanceExpectation performance_expectation = platforms::darwinn::api::PerformanceExpectation_High;
+  std::string public_key{};
+  int64_t watchdog_timeout_ns = 0;
+  int64_t tpu_frequency_hz = -1LL;
+  int64_t max_scheduled_work_ns = -1LL;
+  int64_t host_to_tpu_bps = -1LL;
+  DriverOptionsT() = default;
+  DriverOptionsT(const DriverOptionsT &o);
+  DriverOptionsT(DriverOptionsT&&) FLATBUFFERS_NOEXCEPT = default;
+  DriverOptionsT &operator=(DriverOptionsT o) FLATBUFFERS_NOEXCEPT;
+};
+
+struct DriverOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DriverOptionsT NativeTableType;
+  typedef DriverOptionsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_VERSION = 4,
+    VT_USB = 6,
+    VT_VERBOSITY = 8,
+    VT_PERFORMANCE_EXPECTATION = 10,
+    VT_PUBLIC_KEY = 12,
+    VT_WATCHDOG_TIMEOUT_NS = 14,
+    VT_TPU_FREQUENCY_HZ = 16,
+    VT_MAX_SCHEDULED_WORK_NS = 18,
+    VT_HOST_TO_TPU_BPS = 20
+  };
+  int32_t version() const {
+    return GetField<int32_t>(VT_VERSION, 1);
+  }
+  bool mutate_version(int32_t _version = 1) {
+    return SetField<int32_t>(VT_VERSION, _version, 1);
+  }
+  const platforms::darwinn::api::DriverUsbOptions *usb() const {
+    return GetPointer<const platforms::darwinn::api::DriverUsbOptions *>(VT_USB);
+  }
+  platforms::darwinn::api::DriverUsbOptions *mutable_usb() {
+    return GetPointer<platforms::darwinn::api::DriverUsbOptions *>(VT_USB);
+  }
+  int32_t verbosity() const {
+    return GetField<int32_t>(VT_VERBOSITY, 0);
+  }
+  bool mutate_verbosity(int32_t _verbosity = 0) {
+    return SetField<int32_t>(VT_VERBOSITY, _verbosity, 0);
+  }
+  platforms::darwinn::api::PerformanceExpectation performance_expectation() const {
+    return static_cast<platforms::darwinn::api::PerformanceExpectation>(GetField<int32_t>(VT_PERFORMANCE_EXPECTATION, 2));
+  }
+  bool mutate_performance_expectation(platforms::darwinn::api::PerformanceExpectation _performance_expectation = static_cast<platforms::darwinn::api::PerformanceExpectation>(2)) {
+    return SetField<int32_t>(VT_PERFORMANCE_EXPECTATION, static_cast<int32_t>(_performance_expectation), 2);
+  }
+  const flatbuffers::String *public_key() const {
+    return GetPointer<const flatbuffers::String *>(VT_PUBLIC_KEY);
+  }
+  flatbuffers::String *mutable_public_key() {
+    return GetPointer<flatbuffers::String *>(VT_PUBLIC_KEY);
+  }
+  int64_t watchdog_timeout_ns() const {
+    return GetField<int64_t>(VT_WATCHDOG_TIMEOUT_NS, 0);
+  }
+  bool mutate_watchdog_timeout_ns(int64_t _watchdog_timeout_ns = 0) {
+    return SetField<int64_t>(VT_WATCHDOG_TIMEOUT_NS, _watchdog_timeout_ns, 0);
+  }
+  int64_t tpu_frequency_hz() const {
+    return GetField<int64_t>(VT_TPU_FREQUENCY_HZ, -1LL);
+  }
+  bool mutate_tpu_frequency_hz(int64_t _tpu_frequency_hz = -1LL) {
+    return SetField<int64_t>(VT_TPU_FREQUENCY_HZ, _tpu_frequency_hz, -1LL);
+  }
+  int64_t max_scheduled_work_ns() const {
+    return GetField<int64_t>(VT_MAX_SCHEDULED_WORK_NS, -1LL);
+  }
+  bool mutate_max_scheduled_work_ns(int64_t _max_scheduled_work_ns = -1LL) {
+    return SetField<int64_t>(VT_MAX_SCHEDULED_WORK_NS, _max_scheduled_work_ns, -1LL);
+  }
+  int64_t host_to_tpu_bps() const {
+    return GetField<int64_t>(VT_HOST_TO_TPU_BPS, -1LL);
+  }
+  bool mutate_host_to_tpu_bps(int64_t _host_to_tpu_bps = -1LL) {
+    return SetField<int64_t>(VT_HOST_TO_TPU_BPS, _host_to_tpu_bps, -1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
+           VerifyOffset(verifier, VT_USB) &&
+           verifier.VerifyTable(usb()) &&
+           VerifyField<int32_t>(verifier, VT_VERBOSITY, 4) &&
+           VerifyField<int32_t>(verifier, VT_PERFORMANCE_EXPECTATION, 4) &&
+           VerifyOffset(verifier, VT_PUBLIC_KEY) &&
+           verifier.VerifyString(public_key()) &&
+           VerifyField<int64_t>(verifier, VT_WATCHDOG_TIMEOUT_NS, 8) &&
+           VerifyField<int64_t>(verifier, VT_TPU_FREQUENCY_HZ, 8) &&
+           VerifyField<int64_t>(verifier, VT_MAX_SCHEDULED_WORK_NS, 8) &&
+           VerifyField<int64_t>(verifier, VT_HOST_TO_TPU_BPS, 8) &&
+           verifier.EndTable();
+  }
+  DriverOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DriverOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DriverOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DriverOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DriverOptionsBuilder {
+  typedef DriverOptions Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_version(int32_t version) {
+    fbb_.AddElement<int32_t>(DriverOptions::VT_VERSION, version, 1);
+  }
+  void add_usb(flatbuffers::Offset<platforms::darwinn::api::DriverUsbOptions> usb) {
+    fbb_.AddOffset(DriverOptions::VT_USB, usb);
+  }
+  void add_verbosity(int32_t verbosity) {
+    fbb_.AddElement<int32_t>(DriverOptions::VT_VERBOSITY, verbosity, 0);
+  }
+  void add_performance_expectation(platforms::darwinn::api::PerformanceExpectation performance_expectation) {
+    fbb_.AddElement<int32_t>(DriverOptions::VT_PERFORMANCE_EXPECTATION, static_cast<int32_t>(performance_expectation), 2);
+  }
+  void add_public_key(flatbuffers::Offset<flatbuffers::String> public_key) {
+    fbb_.AddOffset(DriverOptions::VT_PUBLIC_KEY, public_key);
+  }
+  void add_watchdog_timeout_ns(int64_t watchdog_timeout_ns) {
+    fbb_.AddElement<int64_t>(DriverOptions::VT_WATCHDOG_TIMEOUT_NS, watchdog_timeout_ns, 0);
+  }
+  void add_tpu_frequency_hz(int64_t tpu_frequency_hz) {
+    fbb_.AddElement<int64_t>(DriverOptions::VT_TPU_FREQUENCY_HZ, tpu_frequency_hz, -1LL);
+  }
+  void add_max_scheduled_work_ns(int64_t max_scheduled_work_ns) {
+    fbb_.AddElement<int64_t>(DriverOptions::VT_MAX_SCHEDULED_WORK_NS, max_scheduled_work_ns, -1LL);
+  }
+  void add_host_to_tpu_bps(int64_t host_to_tpu_bps) {
+    fbb_.AddElement<int64_t>(DriverOptions::VT_HOST_TO_TPU_BPS, host_to_tpu_bps, -1LL);
+  }
+  explicit DriverOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DriverOptions> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DriverOptions>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DriverOptions> CreateDriverOptions(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t version = 1,
+    flatbuffers::Offset<platforms::darwinn::api::DriverUsbOptions> usb = 0,
+    int32_t verbosity = 0,
+    platforms::darwinn::api::PerformanceExpectation performance_expectation = platforms::darwinn::api::PerformanceExpectation_High,
+    flatbuffers::Offset<flatbuffers::String> public_key = 0,
+    int64_t watchdog_timeout_ns = 0,
+    int64_t tpu_frequency_hz = -1LL,
+    int64_t max_scheduled_work_ns = -1LL,
+    int64_t host_to_tpu_bps = -1LL) {
+  DriverOptionsBuilder builder_(_fbb);
+  builder_.add_host_to_tpu_bps(host_to_tpu_bps);
+  builder_.add_max_scheduled_work_ns(max_scheduled_work_ns);
+  builder_.add_tpu_frequency_hz(tpu_frequency_hz);
+  builder_.add_watchdog_timeout_ns(watchdog_timeout_ns);
+  builder_.add_public_key(public_key);
+  builder_.add_performance_expectation(performance_expectation);
+  builder_.add_verbosity(verbosity);
+  builder_.add_usb(usb);
+  builder_.add_version(version);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<DriverOptions> CreateDriverOptionsDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t version = 1,
+    flatbuffers::Offset<platforms::darwinn::api::DriverUsbOptions> usb = 0,
+    int32_t verbosity = 0,
+    platforms::darwinn::api::PerformanceExpectation performance_expectation = platforms::darwinn::api::PerformanceExpectation_High,
+    const char *public_key = nullptr,
+    int64_t watchdog_timeout_ns = 0,
+    int64_t tpu_frequency_hz = -1LL,
+    int64_t max_scheduled_work_ns = -1LL,
+    int64_t host_to_tpu_bps = -1LL) {
+  auto public_key__ = public_key ? _fbb.CreateString(public_key) : 0;
+  return platforms::darwinn::api::CreateDriverOptions(
+      _fbb,
+      version,
+      usb,
+      verbosity,
+      performance_expectation,
+      public_key__,
+      watchdog_timeout_ns,
+      tpu_frequency_hz,
+      max_scheduled_work_ns,
+      host_to_tpu_bps);
+}
+
+flatbuffers::Offset<DriverOptions> CreateDriverOptions(flatbuffers::FlatBufferBuilder &_fbb, const DriverOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+inline DriverUsbOptionsT *DriverUsbOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DriverUsbOptionsT>(new DriverUsbOptionsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DriverUsbOptions::UnPackTo(DriverUsbOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = dfu_firmware(); if (_e) _o->dfu_firmware = _e->str(); }
+  { auto _e = always_dfu(); _o->always_dfu = _e; }
+  { auto _e = has_fail_if_slower_than_superspeed(); _o->has_fail_if_slower_than_superspeed = _e; }
+  { auto _e = fail_if_slower_than_superspeed(); _o->fail_if_slower_than_superspeed = _e; }
+  { auto _e = has_force_largest_bulk_in_chunk_size(); _o->has_force_largest_bulk_in_chunk_size = _e; }
+  { auto _e = force_largest_bulk_in_chunk_size(); _o->force_largest_bulk_in_chunk_size = _e; }
+  { auto _e = has_enable_overlapping_bulk_in_and_out(); _o->has_enable_overlapping_bulk_in_and_out = _e; }
+  { auto _e = enable_overlapping_bulk_in_and_out(); _o->enable_overlapping_bulk_in_and_out = _e; }
+  { auto _e = has_enable_queued_bulk_in_requests(); _o->has_enable_queued_bulk_in_requests = _e; }
+  { auto _e = enable_queued_bulk_in_requests(); _o->enable_queued_bulk_in_requests = _e; }
+  { auto _e = has_bulk_in_queue_capacity(); _o->has_bulk_in_queue_capacity = _e; }
+  { auto _e = bulk_in_queue_capacity(); _o->bulk_in_queue_capacity = _e; }
+}
+
+inline flatbuffers::Offset<DriverUsbOptions> DriverUsbOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DriverUsbOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDriverUsbOptions(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DriverUsbOptions> CreateDriverUsbOptions(flatbuffers::FlatBufferBuilder &_fbb, const DriverUsbOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DriverUsbOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _dfu_firmware = _o->dfu_firmware.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->dfu_firmware);
+  auto _always_dfu = _o->always_dfu;
+  auto _has_fail_if_slower_than_superspeed = _o->has_fail_if_slower_than_superspeed;
+  auto _fail_if_slower_than_superspeed = _o->fail_if_slower_than_superspeed;
+  auto _has_force_largest_bulk_in_chunk_size = _o->has_force_largest_bulk_in_chunk_size;
+  auto _force_largest_bulk_in_chunk_size = _o->force_largest_bulk_in_chunk_size;
+  auto _has_enable_overlapping_bulk_in_and_out = _o->has_enable_overlapping_bulk_in_and_out;
+  auto _enable_overlapping_bulk_in_and_out = _o->enable_overlapping_bulk_in_and_out;
+  auto _has_enable_queued_bulk_in_requests = _o->has_enable_queued_bulk_in_requests;
+  auto _enable_queued_bulk_in_requests = _o->enable_queued_bulk_in_requests;
+  auto _has_bulk_in_queue_capacity = _o->has_bulk_in_queue_capacity;
+  auto _bulk_in_queue_capacity = _o->bulk_in_queue_capacity;
+  return platforms::darwinn::api::CreateDriverUsbOptions(
+      _fbb,
+      _dfu_firmware,
+      _always_dfu,
+      _has_fail_if_slower_than_superspeed,
+      _fail_if_slower_than_superspeed,
+      _has_force_largest_bulk_in_chunk_size,
+      _force_largest_bulk_in_chunk_size,
+      _has_enable_overlapping_bulk_in_and_out,
+      _enable_overlapping_bulk_in_and_out,
+      _has_enable_queued_bulk_in_requests,
+      _enable_queued_bulk_in_requests,
+      _has_bulk_in_queue_capacity,
+      _bulk_in_queue_capacity);
+}
+
+inline DriverOptionsT::DriverOptionsT(const DriverOptionsT &o)
+      : version(o.version),
+        usb((o.usb) ? new platforms::darwinn::api::DriverUsbOptionsT(*o.usb) : nullptr),
+        verbosity(o.verbosity),
+        performance_expectation(o.performance_expectation),
+        public_key(o.public_key),
+        watchdog_timeout_ns(o.watchdog_timeout_ns),
+        tpu_frequency_hz(o.tpu_frequency_hz),
+        max_scheduled_work_ns(o.max_scheduled_work_ns),
+        host_to_tpu_bps(o.host_to_tpu_bps) {
+}
+
+inline DriverOptionsT &DriverOptionsT::operator=(DriverOptionsT o) FLATBUFFERS_NOEXCEPT {
+  std::swap(version, o.version);
+  std::swap(usb, o.usb);
+  std::swap(verbosity, o.verbosity);
+  std::swap(performance_expectation, o.performance_expectation);
+  std::swap(public_key, o.public_key);
+  std::swap(watchdog_timeout_ns, o.watchdog_timeout_ns);
+  std::swap(tpu_frequency_hz, o.tpu_frequency_hz);
+  std::swap(max_scheduled_work_ns, o.max_scheduled_work_ns);
+  std::swap(host_to_tpu_bps, o.host_to_tpu_bps);
+  return *this;
+}
+
+inline DriverOptionsT *DriverOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DriverOptionsT>(new DriverOptionsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DriverOptions::UnPackTo(DriverOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = version(); _o->version = _e; }
+  { auto _e = usb(); if (_e) { if(_o->usb) { _e->UnPackTo(_o->usb.get(), _resolver); } else { _o->usb = std::unique_ptr<platforms::darwinn::api::DriverUsbOptionsT>(_e->UnPack(_resolver)); } } }
+  { auto _e = verbosity(); _o->verbosity = _e; }
+  { auto _e = performance_expectation(); _o->performance_expectation = _e; }
+  { auto _e = public_key(); if (_e) _o->public_key = _e->str(); }
+  { auto _e = watchdog_timeout_ns(); _o->watchdog_timeout_ns = _e; }
+  { auto _e = tpu_frequency_hz(); _o->tpu_frequency_hz = _e; }
+  { auto _e = max_scheduled_work_ns(); _o->max_scheduled_work_ns = _e; }
+  { auto _e = host_to_tpu_bps(); _o->host_to_tpu_bps = _e; }
+}
+
+inline flatbuffers::Offset<DriverOptions> DriverOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DriverOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDriverOptions(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DriverOptions> CreateDriverOptions(flatbuffers::FlatBufferBuilder &_fbb, const DriverOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DriverOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _version = _o->version;
+  auto _usb = _o->usb ? CreateDriverUsbOptions(_fbb, _o->usb.get(), _rehasher) : 0;
+  auto _verbosity = _o->verbosity;
+  auto _performance_expectation = _o->performance_expectation;
+  auto _public_key = _o->public_key.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->public_key);
+  auto _watchdog_timeout_ns = _o->watchdog_timeout_ns;
+  auto _tpu_frequency_hz = _o->tpu_frequency_hz;
+  auto _max_scheduled_work_ns = _o->max_scheduled_work_ns;
+  auto _host_to_tpu_bps = _o->host_to_tpu_bps;
+  return platforms::darwinn::api::CreateDriverOptions(
+      _fbb,
+      _version,
+      _usb,
+      _verbosity,
+      _performance_expectation,
+      _public_key,
+      _watchdog_timeout_ns,
+      _tpu_frequency_hz,
+      _max_scheduled_work_ns,
+      _host_to_tpu_bps);
+}
+
+inline const platforms::darwinn::api::DriverOptions *GetDriverOptions(const void *buf) {
+  return flatbuffers::GetRoot<platforms::darwinn::api::DriverOptions>(buf);
+}
+
+inline const platforms::darwinn::api::DriverOptions *GetSizePrefixedDriverOptions(const void *buf) {
+  return flatbuffers::GetSizePrefixedRoot<platforms::darwinn::api::DriverOptions>(buf);
+}
+
+inline DriverOptions *GetMutableDriverOptions(void *buf) {
+  return flatbuffers::GetMutableRoot<DriverOptions>(buf);
+}
+
+inline platforms::darwinn::api::DriverOptions *GetMutableSizePrefixedDriverOptions(void *buf) {
+  return flatbuffers::GetMutableSizePrefixedRoot<platforms::darwinn::api::DriverOptions>(buf);
+}
+
+inline bool VerifyDriverOptionsBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<platforms::darwinn::api::DriverOptions>(nullptr);
+}
+
+inline bool VerifySizePrefixedDriverOptionsBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<platforms::darwinn::api::DriverOptions>(nullptr);
+}
+
+inline void FinishDriverOptionsBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<platforms::darwinn::api::DriverOptions> root) {
+  fbb.Finish(root);
+}
+
+inline void FinishSizePrefixedDriverOptionsBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<platforms::darwinn::api::DriverOptions> root) {
+  fbb.FinishSizePrefixed(root);
+}
+
+inline std::unique_ptr<platforms::darwinn::api::DriverOptionsT> UnPackDriverOptions(
+    const void *buf,
+    const flatbuffers::resolver_function_t *res = nullptr) {
+  return std::unique_ptr<platforms::darwinn::api::DriverOptionsT>(GetDriverOptions(buf)->UnPack(res));
+}
+
+inline std::unique_ptr<platforms::darwinn::api::DriverOptionsT> UnPackSizePrefixedDriverOptions(
+    const void *buf,
+    const flatbuffers::resolver_function_t *res = nullptr) {
+  return std::unique_ptr<platforms::darwinn::api::DriverOptionsT>(GetSizePrefixedDriverOptions(buf)->UnPack(res));
+}
+
+}  // namespace api
+}  // namespace darwinn
+}  // namespace platforms
+
+#endif  // FLATBUFFERS_GENERATED_DRIVEROPTIONS_PLATFORMS_DARWINN_API_H_
